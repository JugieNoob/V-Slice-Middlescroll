import funkin.play.PlayState;
import funkin.modding.module.Module;
import flixel.FlxG;
import funkin.play.notes.Strumline;
import funkin.util.Constants;
import StringTools;
import flixel.text.FlxText;

class Middlescroll extends Module {
	var noteOffset:Int = 0;
	var isPixel:Int = false;

	// public var MiddlescrollOptions.isMobile:Bool = false;

	var playerStrumline:FlxSprite;
	var opponentStrumline:FlxSprite;

	var differentLanes = false;
	var noteSpacing = 0;

	var debugtext;

	function new() {
		super("Middlescroll");
	}
	
	// ----- Override Functions
	override function onUpdate() {

		super.onUpdate();
		if (PlayState.instance != null) {

			if (FlxG.save.data.middlescroll != "Off") {
				if (MiddlescrollOptions.isMobile)
				{
					updateNoteCovers(playerStrumline);
				}
				else if (FlxG.save.data.middlescroll == "Wide Lanes" )
				{
					updateNoteCovers(playerStrumline);
					updateNoteCovers(opponentStrumline);
				}
				else
				{
					updateNoteCovers(opponentStrumline);
				}
			}
			
			if (FlxG.save.data.oppnotes == "Translucent") {
				if (opponentStrumline != null)
				{
					opponentStrumline.alpha = 0.5;
					if (opponentStrumline.strumlineNotes != null) {
						for (note in opponentStrumline.strumlineNotes)
						{
							note.alpha = 0.5;
						}
					}
				}
			
			}

		}
	}

	override function onCountdownStart(event) {
		super.onCountdownStart(event);

		
	    debugtext = new FlxText();
        // debugtext.text = "Combo: " + combo + "\nSong Position: " + Conductor.instance.songPosition + "\nnotehittime: " + notehittime + "\nholdnoteend: " + holdnoteend + "\nholdnoteendtime: " + holdnoteendtime +"\ncurrent step: " + Conductor.instance.currentStep + "\nhashitnote: " + hashitnote + "\nscreen width: " + FlxG.width;
        debugtext.cameras = [PlayState.instance.camHUD];
        debugtext.size = 18;
        debugtext.updateHitbox();
        debugtext.setPosition(30, FlxG.height - debugtext.height - 40);
        debugtext.zIndex = 1000;
        PlayState.instance.add(debugtext);


		if (FlxG.save.data.middlescroll == "Wide Lanes" || FlxG.save.data.middlescroll == "Narrow Lanes")
		{
			differentLanes = true;
		}
		else
		{
			differentLanes = false;
		}

		playerStrumline = PlayState.instance.playerStrumline;
		opponentStrumline = PlayState.instance.opponentStrumline;


		isPixel = playerStrumline.noteStyle.isHoldNotePixel();
		var strumOffset = playerStrumline.noteStyle.getStrumlineOffsets();
		noteOffset = strumOffset[0] + strumOffset[1];



	

		

		if (FlxG.save.data.movepopups) {
			// Taken from Blazin'
			PlayState.instance.comboPopUps.offsets = [480, -50];
		}

		
		if (FlxG.save.data.middlescroll != "Off") {
			setPlayerStrumline();
			if (!MiddlescrollOptions.isMobile)
			{
				moveOpponentStrumline();
			}
		}

		if (FlxG.save.data.oppnotes == "Hidden") {
			hideOpponentStrumline();
		}


	}

	override function onNoteIncoming(event) {

		super.onNoteIncoming(event);

		if (event.note.noteData.getMustHitNote())
		{

			if (MiddlescrollOptions.isMobile || differentLanes)
			{
				// Previous method done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)
				
				// event.note.updateHitbox();
				// event.note.updateHitbox();
				event.note.x = playerStrumline.x;
				// event.note.x += event.note.width / 1.5;
				event.note.x += (event.note.direction * (Strumline.STRUMLINE_SIZE + noteSpacing)) - Strumline.NUDGE;
				// event.note.x -= event.note.width / 2;
				if (event.note.offset.x >= 40)
				{
					event.note.x -= event.note.offset.x;
				}
				if (event.note.get_kind() == "trickydeath")
				{
					event.note.x -= (playerStrumline.strumlineNotes.members[0].width / 2) - 15;
				}


				if (event.note.holdNoteSprite != null)
				{
					var hold = event.note.holdNoteSprite;
				
					hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2);
				}
			}
		}
	
		if (!MiddlescrollOptions.isMobile)
		{
			if (!event.note.noteData.getMustHitNote())
			{
				// Account for strumline offset.
				var dist = opponentStrumline.x - opponentStrumline.strumlineNotes.members[0].x;
				if (event.note.direction > 1)
				{
					event.note.x = opponentStrumline.strumlineNotes.members[event.note.direction].x + dist;
					// event.note.x += ((event.note.direction - 2) * (Strumline.STRUMLINE_SIZE)) - Strumline.NUDGE;
					if (event.note.holdNoteSprite != null)
					{
						var hold = event.note.holdNoteSprite;
					
						hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2);
					}
				}
				
				// for (hold in opponentStrumline.holdNotes)
				// {
				// 	var strumNote = opponentStrumline.strumlineNotes.members[hold.noteDirection];
				// 	hold.x = strumNote.x + (strumNote.width / 2) - (hold.width / 2);			
				// }
			}
		}

		if (FlxG.save.data.oppnotes == "Translucent")
		{
			translucentOpponentNotes();
		}


	}

	override function onNoteHit(event)
	{
		super.onNoteHit(event);

		if (FlxG.save.data.middlescroll != "Off")
		{
			if (event.doesNotesplash)
			{
				if (MiddlescrollOptions.isMobile || differentLanes)
				{
					event.doesNotesplash = false;
					playerStrumline.playNoteSplash(event.note.direction);
					
					for (splash in playerStrumline.noteSplashes)
					{
						var direction = 0;

						if (StringTools.contains(splash.animation.name, "LEFT"))
						{
							direction = 0;
						}
						else if (StringTools.contains(splash.animation.name, "DOWN"))
						{
							direction = 1;
						}
						else if (StringTools.contains(splash.animation.name, "UP"))
						{
							direction = 2;
						}
						else if (StringTools.contains(splash.animation.name, "RIGHT"))
						{
							direction = 3;
						}
						if (event.note.direction == direction)
						{
							splash.x = event.note.x + (playerStrumline.noteStyle.getSplashOffsets()[0] * 1.75);
						}

					}
				}
			
			}
		}

	}

	// ----- Custom Functions

	function setPlayerStrumline()
	{
		// Previous version done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)

		// playerStrumline.x = (FlxG.width / 2 - playerStrumline.strumlineNotes.width / 2) - (playerStrumline.strumlineNotes.members[0].width / 1.5);
		debugtext.text = "middle: " + ((FlxG.width - playerStrumline.width) / 2);

		switch (FlxG.save.data.middlescroll)
		{
			case "Wide Lanes":
				noteSpacing = 60;
			case "Narrow Lanes":
				noteSpacing = 10;
			default:
				if (MiddlescrollOptions.isMobile)
				{
					noteSpacing = 45;//45;	
				}
				else
				{
					noteSpacing = 0;
				}
		}

		var originalPos = (FlxG.width - playerStrumline.width) / 2; 
		
		if (MiddlescrollOptions.isMobile || differentLanes)
		{
			for (i in 0...playerStrumline.strumlineNotes.length) {
				var note = playerStrumline.strumlineNotes.members[i];
				note.x = playerStrumline.strumlineNotes.members[0].x;
				note.x += (i * (Strumline.STRUMLINE_SIZE + noteSpacing));
				
			}
			// playerStrumline.background.setGraphicSize(playerStrumline.strumlineNotes.width - Strumline.BACKGROUND_PAD, FlxG.height + 50); //(4 * ((Strumline.NOTE_SPACING + noteSpacing) + (Strumline.BACKGROUND_PAD * 2)))
			//4 * (Strumline.STRUMLINE_SIZE + noteSpacing) - Strumline.BACKGROUND_PAD
			// playerStrumline.background.setGraphicSize(4 * (Strumline.STRUMLINE_SIZE + noteSpacing), FlxG.height + 50);
			// playerStrumline.background.setGraphicSize(playerStrumline.background.width + (Strumline.STRUMLINE_SIZE / 2) + noteSpacing + (Strumline.BACKGROUND_PAD / 2), FlxG.height + 50);
			// playerStrumline.x = (FlxG.width - playerStrumline.background.width) / 2;
			// playerStrumline.x = ((FlxG.width - playerStrumline.width) / 2) - (noteSpacing + (Strumline.BACKGROUND_PAD / 2));
		}
		//
		var firststrumNote = playerStrumline.strumlineNotes.members[0];
		// playerStrumline.x = ((FlxG.width - (firststrumNote.width + (3 * (Strumline.STRUMLINE_SIZE + noteSpacing)))) + firststrumNote.offset.x) / 2;//playerStrumline.strumlineNotes.members[0].width) );
		// playerStrumline.x += noteSpacing * (2 - 1.45);
		
		playerStrumline.x = (FlxG.width / 2) - (2 * ((Strumline.STRUMLINE_SIZE))) + (Strumline.STRUMLINE_SIZE / 4) - (noteSpacing * 4.2);

		debugtext.text += "\nStrumline x: " + playerStrumline.x + " difference: " + (originalPos - playerStrumline.x);

		// playerStrumline.background.setGraphicSize((4 * (Strumline.STRUMLINE_SIZE) + ((Strumline.BACKGROUND_PAD + noteSpacing) * 2)), FlxG.height + 50); //2.85
		// playerStrumline.background.updateHitbox();

		// playerStrumline.background.setGraphicSize()

		 //(FlxG.width / 2) - (playerStrumline.background.width / 2) + (noteSpacing / 4);//(playerStrumline.width / 2) - noteSpacing;

		// if (FlxG.save.data.middlescroll != "Wide Lanes")
		// {
		// 	playerStrumline.x = ((FlxG.width / 2) - (playerStrumline.width / 2)) - noteSpacing;			
		// }
		// else
		// {
		// 	playerStrumline.x = ((FlxG.width / 2) - (playerStrumline.width / 2)) - (noteSpacing * 1.25);
		// }
		// playerStrumline.x = (FlxG.width / 2) - (2 * (Strumline.STRUMLINE_SIZE + noteSpacing)) + (noteSpacing / 3);
		//+ (noteSpacing / 3)
		

		switch (FlxG.save.data.noteEffects)
		{
			case "None":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = false;
			case "Splashes Only":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = true;
			case "Hold Covers Only":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = false;
			case "All":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = true;
		}
	

	}

	function moveOpponentStrumline() {
		opponentStrumline.remove(opponentStrumline.background);


		if (opponentStrumline != null) {
			for (i in 2...opponentStrumline.strumlineNotes.length) {
				var opponentNote = opponentStrumline.strumlineNotes.members[i];
				opponentNote.x = (FlxG.width + ((Constants.STRUMLINE_X_OFFSET - opponentNote.width - noteOffset) * (opponentStrumline.strumlineNotes.length - i))
					- (Constants.STRUMLINE_X_OFFSET * 1.5))
					+ (noteOffset / 2);
			}
		}
	}

	function updateNoteCovers(strumline)
	{
		var direction = 0;
		if (strumline != null)
		{
			if (strumline.noteHoldCovers != null)
			{
				for (cover in strumline.noteHoldCovers)
				{
				
					if (StringTools.contains(cover.glow.animation.name, "Blue"))
					{
						direction = 1;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Green"))
					{
						direction = 2;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Red"))
					{
						direction = 3;
					}
					else
					{
						direction = 0;
					}

					var note = strumline.strumlineNotes.members[direction];
					cover.glow.x = note.x - note.width / 2 - ((strumline.noteStyle.getHoldCoverOffsets()[0] * (isPixel ? 2 : 1))* cover.scale.x) + (isPixel ? strumline.noteStyle.getHoldCoverOffsets()[0] - 12: -noteOffset);

				}
			}
		}
		

		
	
	}
	// Taken from Blazin'
	function hideOpponentStrumline() {
		if (opponentStrumline != null) {
			opponentStrumline.visible = false;
		}
	}

	function translucentOpponentNotes()
	{
		// Move incoming notes
		for (note in opponentStrumline.notes)
		{
			note.alpha = 0.5;
		}
		for (hold in opponentStrumline.holdNotes)
		{
			hold.alpha = 0.5;
		}
		
	}

	function getXPos(direction, strumline):Float
  	{
  	  var pos:Float = 0;

	  return switch (direction)
  	  {
  	    case 0: -pos * 2;
  	    case 1:
  	      -(pos * 2) + (1 * Strumline.NOTE_SPACING + noteSpacing) * (strumline.noteSpacingScale * strumline.strumlineScale.x);
  	    case 2:
  	      pos + (2 * Strumline.NOTE_SPACING + noteSpacing) * (strumline.noteSpacingScale * strumline.strumlineScale.x);
  	    case 3:
  	      pos + (3 * Strumline.NOTE_SPACING + noteSpacing) * (strumline.noteSpacingScale * strumline.strumlineScale.x);
  	    default: -pos * 2;
  	  }
  	}
}

