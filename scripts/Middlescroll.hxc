import funkin.play.PlayState;
import funkin.modding.module.Module;
import flixel.FlxG;
import funkin.play.notes.Strumline;
import funkin.util.Constants;
import funkin.Preferences;
import StringTools;
import flixel.tweens.FlxTween;
import flixel.tweens.FlxEase;
import flixel.util.FlxTimer;

/*
	Middlescroll V-Slice created by JugieNoob
	GitHub Link: https://github.com/JugieNoob/V-Slice-Middlescroll
	GameBanana Link: https://gamebanana.com/mods/516762
*/

class Middlescroll extends Module {

	var playerStrumline:FlxSprite;
	private var opponentStrumline:FlxSprite;

	var differentLanes = false;
	var noteSpacing = 0;
	var mobilePos = 0;


	var oldCoverPositions = [0,0,0,0];
	var coverPositions = [];
	var oldOppPositions = [];
	var oldOppCoverPositions = [0,0];

	var currentState;

	function new() {
		super("Middlescroll", 0,  {state: PlayState});
	}

	// ----- Override Functions
	override function onUpdate() {
		super.onUpdate();
		if (PlayState.instance == null)
		{
			return;
		}

		if (FlxG.save.data.middlescroll == "Off" && !FlxG.save.data.alwaysOppNotes)
		{
			return;
		}
		if (FlxG.save.data.oppnotes == "Translucent")
		{
			for (cover in PlayState.instance.opponentStrumline.noteHoldCovers)
			{
				cover.alpha = 0.5;
			}
		}


		if (FlxG.save.data.middlescroll == "Off")
		{
			return;
		}

		if (!PlayState.instance.isInCutscene)
		{
				if (Preferences.controlsScheme == "Arrows")
				{
					updateNoteCovers(playerStrumline, true);
				}
				else if (differentLanes)
				{
					updateNoteCovers(playerStrumline, true);
					updateNoteCovers(opponentStrumline);
				}
				else
				{
					updateNoteCovers(opponentStrumline);
				}

		}
		if (PlayState.instance.currentSong == "Song(blazin)")
		{
			if (playerStrumline != null)
			{	
				setPlayerStrumline();
			}
		}
	}

	override function onStateChangeEnd(event) {
		super.onStateChangeEnd(event);

		currentState = event.targetState;

		if (!Std.isOfType(event.targetState, PlayState))
        {
			return;
		}

		init();


	}

	override function onCountdownStart(event)
	{
		super.onCountdownStart(event);
		init();


	}




	override function onNoteIncoming(event) {

		super.onNoteIncoming(event);

		if (FlxG.save.data.middlescroll == "Off" && !FlxG.save.data.alwaysOppNotes)
		{
			return;
		}

		if (Preferences.controlsScheme != "Arrows" && FlxG.save.data.oppnotes == "Translucent")
				{
					if (!event.note.noteData.getMustHitNote())
					{
						event.note.alpha = 0.5;

						if (event.note.holdNoteSprite != null)
						{
							event.note.holdNoteSprite.alpha = 0.5;
						}
					}
				}




		if (FlxG.save.data.middlescroll == "Off")
		{
			return;
		}

		if (Preferences.controlsScheme == "Arrows" || differentLanes)
		{
			if (event.note.noteData.getMustHitNote())
			{
				// Previous method done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)

				event.note.x += (event.note.direction * (Strumline.STRUMLINE_SIZE + noteSpacing));

				if (Preferences.controlsScheme == "Arrows" && event.note.direction > 1)
				{
					event.note.x -= mobilePos * 3;
				}



				if (event.note.holdNoteSprite != null)
				{
					var hold = event.note.holdNoteSprite;
					hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2) + Strumline.NUDGE;
				}
			}
		}


		if (Preferences.controlsScheme != "Arrows")
		{
			if (!event.note.noteData.getMustHitNote())
			{
				if (event.note.direction > 1)
				{
					var dist = opponentStrumline.strumlineNotes.members[2].x - opponentStrumline.strumlineNotes.members[1].x;

					event.note.x += dist;
					event.note.x -= Strumline.STRUMLINE_SIZE;
					event.note.x -= Strumline.NUDGE * 3;

					if (event.note.holdNoteSprite != null)
					{
						var hold = event.note.holdNoteSprite;

						hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2);
					}
				}
			}
		}

	}

	override function onNoteHit(event)
	{
		super.onNoteHit(event);


		if (FlxG.save.data.middlescroll != "Off")
		{
			if (event.doesNotesplash)
			{
				if (Preferences.controlsScheme == "Arrows" || differentLanes)
				{
					event.doesNotesplash = false;
					playerStrumline.playNoteSplash(event.note.direction);
				
					for (splash in playerStrumline.noteSplashes)
					{
						var direction = 0;

						if (StringTools.contains(splash.animation.name, "LEFT"))
						{
							direction = 0;
						}
						else if (StringTools.contains(splash.animation.name, "DOWN"))
						{
							direction = 1;
						}
						else if (StringTools.contains(splash.animation.name, "UP"))
						{
							direction = 2;
						}
						else if (StringTools.contains(splash.animation.name, "RIGHT"))
						{
							direction = 3;
						}
						if (event.note.direction == direction)
						{
							// Adapted from FNF Source Code
							splash.x = playerStrumline.x;
      						splash.x += playerStrumline.getXPos(direction);
      						splash.x += Strumline.INITIAL_OFFSET;
      						splash.x += playerStrumline.noteStyle.getSplashOffsets()[0] * splash.scale.x;
							splash.x += coverPositions[direction];
							if (direction > 1)
							{
								splash.x -= mobilePos * 3;
							}
						}

					}
				}

			}
		}

	}

	// ----- Custom Functions

	function setPlayerStrumline()
	{
		// Previous version done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)


		if (Preferences.controlsScheme == "Arrows" || differentLanes)
		{

			positionStrumline(playerStrumline, noteSpacing);


			playerStrumline.background.setGraphicSize(4 * (Strumline.STRUMLINE_SIZE + (noteSpacing / 1.3)) + (Strumline.BACKGROUND_PAD * 2) + (mobilePos / 1.6), FlxG.height + 50);
			playerStrumline.background.updateHitbox();
		}
		else
		{
			playerStrumline.x = (FlxG.width - playerStrumline.width) / 2;
		}


		switch (FlxG.save.data.noteEffects)
		{
			case "None":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = false;
			case "Splashes Only":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = true;
			case "Hold Covers Only":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = false;
			case "All":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = true;
		}


	}

	function moveOpponentStrumline() {
		opponentStrumline.background.visible = false;

		if (opponentStrumline != null) {
			for (i in 2...opponentStrumline.strumlineNotes.length) {
				var opponentNote = opponentStrumline.strumlineNotes.members[i];
				oldOppPositions.push(opponentNote.x);

				opponentNote.x = FlxG.width;
				opponentNote.x += (Strumline.NOTE_SPACING) * (i-2);
				opponentNote.x -= (((Strumline.STRUMLINE_SIZE / 2) + (Constants.STRUMLINE_X_OFFSET * 2)) * 2) - opponentStrumline.noteStyle.getStrumlineOffsets()[0];
			}
		}
	}

	function updateNoteCovers(strumline:Strumline, isPlayer:Bool = false)
	{
			if (strumline != null && strumline.noteHoldCovers != null)
			{

				for (cover in strumline.noteHoldCovers)
				{
					var direction = 0;

					if (StringTools.contains(cover.glow.animation.name, "Blue"))
					{
						direction = 1;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Green"))
					{
						direction = 2;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Red"))
					{
						direction = 3;
					}



					if (isPlayer)
					{

						if (oldCoverPositions[direction] == 0)
						{
							oldCoverPositions[direction] = cover.x;
							if (direction > 1)
							{
								oldCoverPositions[direction] -= mobilePos * 3;
							}
						}
						cover.x = (oldCoverPositions[direction] + coverPositions[direction]); //
					}
					else
					{
						if (direction > 1)
						{

							if (oldOppCoverPositions[direction - 2] == 0)
							{
								oldOppCoverPositions[direction -2] = cover.x;
							}
							
							cover.x = oldOppCoverPositions[direction-2] + (strumline.strumlineNotes.members[direction].x - oldOppPositions[direction - 2]);

						}
					}

			}
		}




	}


	public static function positionStrumline(strumline, thisNoteSpacing)
	{
		strumline.setNoteSpacing(0);

		for (strum in strumline)
    	{
    		strum.width /= 2;
    	}

		if (Preferences.controlsScheme == "Arrows")
		{
			mobilePos = 35 * (FlxG.width / FlxG.height) / (FlxG.initialWidth / FlxG.initialHeight);
		}

		for (i in 0...strumline.strumlineNotes.length) {

			var note = strumline.strumlineNotes.members[i];
			note.x += (i * (Strumline.STRUMLINE_SIZE + thisNoteSpacing));

			if (Preferences.controlsScheme == "Arrows")
			{
				if (note.direction > 1)
				{
					note.x -= (mobilePos * 3);
				}
			}
		}

		strumline.x = (FlxG.width - (4 * (Strumline.STRUMLINE_SIZE + (thisNoteSpacing / 1.3)))) / 2;//
		if (Preferences.controlsScheme == "Arrows")
		{
			strumline.x += mobilePos * 2.1;
		}
	}

	function init()
	{
		mobilePos = 0;
		oldCoverPositions = [0,0,0,0];
		coverPositions = [];
		oldOppPositions = [];
		oldOppCoverPositions = [0,0];

		if (FlxG.save.data.middlescroll == "Wide Lanes" || FlxG.save.data.middlescroll == "Narrow Lanes")
		{
			differentLanes = true;
		}
		else
		{
			differentLanes = false;
		}

		switch (FlxG.save.data.middlescroll)
		{
			case "Wide Lanes":
				if (Preferences.controlsScheme == "Arrows")
				{
					noteSpacing = 80;
				}
				else
				{
					noteSpacing = 60;
				}
			case "Narrow Lanes":
				noteSpacing = 30;
			default:
				if (Preferences.controlsScheme == "Arrows")
				{
					noteSpacing = 45;
				}
				else
				{
					noteSpacing = 0;
				}
		}

		if (Preferences.controlsScheme == "Arrows")
		{
			mobilePos = 35 * (FlxG.width / FlxG.height) / (FlxG.initialWidth / FlxG.initialHeight);
		}

		for (i in 0...Strumline.KEY_COUNT)
		{
			coverPositions.push((i * (Strumline.STRUMLINE_SIZE + noteSpacing))); //- (mobilePos * 3)
		}

		playerStrumline = PlayState.instance.playerStrumline;
		opponentStrumline = PlayState.instance.opponentStrumline;



		switch (FlxG.save.data.movepopups)
		{
			case "Always":
				// Taken from Blazin'
				PlayState.instance.comboPopUps.offsets = [480, -50];
			case "Middlescroll Only":
				if (FlxG.save.data.middlescroll != "Off")
				{
					PlayState.instance.comboPopUps.offsets = [480, -50];
				}
		}



		// slight delay or else the player's strumline won't be set properly in Blazin'
		// new FlxTimer().start(0.105, ()->{
		if (FlxG.save.data.middlescroll != "Off") {
				setPlayerStrumline();
				trace("SONG: " + PlayState.instance.currentSong);
				if (PlayState.instance.currentSong != "Song(blazin)")
				{
					if (Preferences.controlsScheme != "Arrows")
					{
						moveOpponentStrumline();
					}
				}	
		}
		// });

		if (FlxG.save.data.middlescroll == "Off" && !FlxG.save.data.alwaysOppNotes)
		{
			return;
		}

		switch (FlxG.save.data.oppnotes)
		{
			case "Hidden":
				// Taken from Blazin'
				if (opponentStrumline != null) {
					opponentStrumline.visible = false;
				}
			case "Translucent":
				opponentStrumline.visible = true;
				opponentStrumline.strumlineNotes.alpha = 0.5;
				// Use custom animation when spawning in strumline notes.
				for (arrow in opponentStrumline.strumlineNotes)
				{
					FlxTween.cancelTweensOf(arrow);
					arrow.alpha = 0.0;
					FlxTween.tween(arrow, {y: arrow.y + 10, alpha: 0.5}, 1, {ease: FlxEase.circOut, startDelay: 0.5 + (0.2 * arrow.direction)});
				}
			default:
				opponentStrumline.visible = true;
		}
	}


}

