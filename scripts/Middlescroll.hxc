import funkin.play.PlayState;
import funkin.modding.module.Module;
import flixel.FlxG;
import funkin.play.notes.Strumline;
import funkin.util.Constants;
import StringTools;
import flixel.text.FlxText;
import flixel.tweens.FlxTween;
import flixel.tweens.FlxEase;

class Middlescroll extends Module {
	var isPixel:Int = false;

	var playerStrumline:FlxSprite;
	var opponentStrumline:FlxSprite;

	var differentLanes = false;
	var noteSpacing = 0;

	function new() {
		super("Middlescroll");
	}
	
	// ----- Override Functions
	override function onUpdate() {

		super.onUpdate();
		if (PlayState.instance != null) {

			if (FlxG.save.data.middlescroll != "Off") {
				if (MiddlescrollOptions.isMobile)
				{
					updateNoteCovers(playerStrumline);
				}
				else if (FlxG.save.data.middlescroll == "Wide Lanes" )
				{
					updateNoteCovers(playerStrumline);
					updateNoteCovers(opponentStrumline);
				}
				else
				{
					updateNoteCovers(opponentStrumline);
				}
			}
			// if (opponentStrumline != null){
			// 	if (FlxG.save.data.oppnotes == "Translucent")
			// 	{
			// 		for (hold in opponentStrumline.holdNotes)
			// 		{
			// 			hold.alpha = 0.5;
			// 		}
			// 	}
			// }
			


		}
	}


	override function onCountdownStart(event) {
		super.onCountdownStart(event);

		if (FlxG.save.data.middlescroll == "Wide Lanes" || FlxG.save.data.middlescroll == "Narrow Lanes")
		{
			differentLanes = true;
		}
		else
		{
			differentLanes = false;
		}

		playerStrumline = PlayState.instance.playerStrumline;
		opponentStrumline = PlayState.instance.opponentStrumline;


		isPixel = playerStrumline.noteStyle.isHoldNotePixel();

		if (FlxG.save.data.movepopups) {
			// Taken from Blazin'
			PlayState.instance.comboPopUps.offsets = [480, -50];
		}


		if (FlxG.save.data.middlescroll != "Off") {
			setPlayerStrumline();
			if (!MiddlescrollOptions.isMobile)
			{
				moveOpponentStrumline();
			}
		}

		if (FlxG.save.data.oppnotes == "Hidden") {
			// Taken from Blazin'
			if (opponentStrumline != null) {
				opponentStrumline.visible = false;
			}		
		}
		if (FlxG.save.data.oppnotes == "Translucent")
		{
			opponentStrumline.alpha = 0.5;

			for (arrow in opponentStrumline.strumlineNotes)
			{
				FlxTween.cancelTweensOf(arrow);

				arrow.y -= 10;
    			arrow.alpha = 0.0;
    			FlxTween.tween(arrow, {y: arrow.y + 10, alpha: 0.5}, 1, {ease: FlxEase.circOut, startDelay: 0.5 + (0.2 * arrow.direction)});
			}
    

		}

	}

	override function onNoteIncoming(event) {

		super.onNoteIncoming(event);

		if (event.note.noteData.getMustHitNote())
		{

			if (MiddlescrollOptions.isMobile || differentLanes)
			{
				// Previous method done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)

				if (MiddlescrollOptions.isMobile)
				{
					event.note.x = playerStrumline.strumlineNotes.members[0].x;
					if (playerStrumline.noteStyle.getName() == "Funkin'")
					{
						event.note.x += event.note.offset.x + Strumline.NUDGE;
					}
				}
				else
				{
					event.note.x = playerStrumline.x;
				}			
				event.note.x += (event.note.direction * (Strumline.STRUMLINE_SIZE + noteSpacing)) - Strumline.NUDGE;

				// if (event.note.offset.x >= 40)
				// {
				// 	event.note.x -= event.note.offset.x;
				// }
				// if (event.note.get_kind() == "trickydeath")
				// {
				// 	event.note.x -= (playerStrumline.strumlineNotes.members[0].width / 2) - 15;
				// }


				if (event.note.holdNoteSprite != null)
				{
					var hold = event.note.holdNoteSprite;
					hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2);
				}
			}
		}
	
		if (!MiddlescrollOptions.isMobile)
		{
			if (!event.note.noteData.getMustHitNote())
			{
				// Account for strumline offset.
				var dist = opponentStrumline.x - opponentStrumline.strumlineNotes.members[0].x;
				if (event.note.direction > 1)
				{
					event.note.x = opponentStrumline.strumlineNotes.members[event.note.direction].x + dist;
			
					if (event.note.holdNoteSprite != null)
					{
						var hold = event.note.holdNoteSprite;
					
						hold.x = (event.note.x + (event.note.width / 2)) - (hold.width / 2);
						hold.setColorTransform(1,1,1,0.5);
						
					}
				}
				
				if (FlxG.save.data.oppnotes == "Translucent") 
				{
					if (opponentStrumline != null)
					{
						opponentStrumline.holdNotes.forEach(function(hold){
							hold.alpha = 0.5;
						});
					}
			
				}
		
			}
		}
	}

	override function onNoteHit(event)
	{
		super.onNoteHit(event);

		if (FlxG.save.data.middlescroll != "Off")
		{
			if (event.doesNotesplash)
			{
				if (MiddlescrollOptions.isMobile || differentLanes)
				{
					event.doesNotesplash = false;
					playerStrumline.playNoteSplash(event.note.direction);
					
					for (splash in playerStrumline.noteSplashes)
					{
						var direction = 0;

						if (StringTools.contains(splash.animation.name, "LEFT"))
						{
							direction = 0;
						}
						else if (StringTools.contains(splash.animation.name, "DOWN"))
						{
							direction = 1;
						}
						else if (StringTools.contains(splash.animation.name, "UP"))
						{
							direction = 2;
						}
						else if (StringTools.contains(splash.animation.name, "RIGHT"))
						{
							direction = 3;
						}
						if (event.note.direction == direction)
						{
							splash.x = event.note.x + (playerStrumline.noteStyle.getSplashOffsets()[0] * 1.75);
						}

					}
				}
			
			}
		}

	}

	// ----- Custom Functions

	function setPlayerStrumline()
	{
		// Previous version done with help from Mofoy on GameBanana (https://gamebanana.com/members/4648991)
  		Strumline.STRUMLINE_SIZE = 104;
		switch (FlxG.save.data.middlescroll)
		{
			case "Wide Lanes":
				noteSpacing = 60;
			case "Narrow Lanes":
				noteSpacing = 10;
			default:
				if (MiddlescrollOptions.isMobile)
				{
					noteSpacing = 100;
				}
				else
				{
					noteSpacing = 0;
				}
		}		

		playerStrumline.x = (FlxG.width - playerStrumline.width) / 2;
		if (MiddlescrollOptions.isMobile || differentLanes)
		{
			for (i in 0...playerStrumline.strumlineNotes.length) {
				var note = playerStrumline.strumlineNotes.members[i];
				note.x = playerStrumline.strumlineNotes.members[0].x;
				note.x += (i * (Strumline.STRUMLINE_SIZE + noteSpacing));
				
			}

			// playerStrumline.background.setGraphicSize(4 * (Strumline.STRUMLINE_SIZE + (noteSpacing / 1.3)) + (Strumline.BACKGROUND_PAD * 2), FlxG.height + 50);
			// playerStrumline.background.updateHitbox();

			playerStrumline.x = FlxG.width - (4 * (Strumline.STRUMLINE_SIZE + (noteSpacing / 1.3)));//
			playerStrumline.x = playerStrumline.x / 2;
		}
		



		switch (FlxG.save.data.noteEffects)
		{
			case "None":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = false;
			case "Splashes Only":
				playerStrumline.noteHoldCovers.visible = false;
				playerStrumline.noteSplashes.visible = true;
			case "Hold Covers Only":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = false;
			case "All":
				playerStrumline.noteHoldCovers.visible = true;
				playerStrumline.noteSplashes.visible = true;
		}
	

	}

	function moveOpponentStrumline() {
		opponentStrumline.remove(opponentStrumline.background);

		if (opponentStrumline != null) {
			for (i in 2...opponentStrumline.strumlineNotes.length) {
				var opponentNote = opponentStrumline.strumlineNotes.members[i];
				opponentNote.x = FlxG.width;
				// if (opponentStrumline.noteStyle.getStrumlineOffsets()[0] == 0)
				// {
				// 	opponentNote.x -= (opponentNote.width - opponentNote.offset.x);
				// }
				// else
				// {
				opponentNote.x -= opponentNote.width - opponentNote.offset.x;
				// }
				opponentNote.x -= Constants.STRUMLINE_X_OFFSET;
				// opponentNote.x -= (opponentNote.width * 1.1) * (3 - i);
				opponentNote.x -= (opponentNote.offset.x * 2) * (3-i);

				// opponentNote.x = (FlxG.width + ((Constants.STRUMLINE_X_OFFSET - opponentNote.width - opponentStrumline.noteStyle.getStrumlineOffsets()[0]) * (opponentStrumline.strumlineNotes.length - i))
				// 	- (Constants.STRUMLINE_X_OFFSET * 1.5))
				// 	+ ((opponentStrumline.noteStyle.getStrumlineOffsets()[0] + opponentNote.offset.x) / 2);
			}
		}
	}

	function updateNoteCovers(strumline)
	{
		var direction = 0;
		if (strumline != null)
		{
			if (strumline.noteHoldCovers != null)
			{
				for (cover in strumline.noteHoldCovers)
				{
					if (StringTools.contains(cover.glow.animation.name, "Blue"))
					{
						direction = 1;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Green"))
					{
						direction = 2;
					}
					else if (StringTools.contains(cover.glow.animation.name, "Red"))
					{
						direction = 3;
					}
					else
					{
						direction = 0;
					}

					var note = strumline.strumlineNotes.members[direction];
					cover.glow.x = note.x - note.width / 2 - ((strumline.noteStyle.getHoldCoverOffsets()[0] * (isPixel ? 2 : 1))* cover.scale.x) + (isPixel ? strumline.noteStyle.getHoldCoverOffsets()[0] - 12: -strumline.noteStyle.getHoldCoverOffsets()[0]);
					if (FlxG.save.data.oppnotes == "Translucent") 
					{
						cover.alpha = 0.5;
					}
				}
			}
		}
		

		
	
	}

}

